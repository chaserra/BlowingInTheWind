{"ast":null,"code":"import _defineProperty from \"@babel/runtime-corejs3/helpers/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime-corejs3/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime-corejs3/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = _Object$keys(object);\n  if (_Object$getOwnPropertySymbols) {\n    var symbols = _Object$getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = _filterInstanceProperty(symbols).call(symbols, function (sym) {\n        return _Object$getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      var _context21;\n      _forEachInstanceProperty(_context21 = ownKeys(Object(source), true)).call(_context21, function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (_Object$getOwnPropertyDescriptors) {\n      _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source));\n    } else {\n      var _context22;\n      _forEachInstanceProperty(_context22 = ownKeys(Object(source))).call(_context22, function (key) {\n        _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport _setInterval from \"@babel/runtime-corejs3/core-js-stable/set-interval\";\nimport _indexOfInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/index-of\";\nimport _spliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/splice\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport _Date$now from \"@babel/runtime-corejs3/core-js-stable/date/now\";\nimport _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols\";\nimport _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors\";\nimport _Object$defineProperties from \"@babel/runtime-corejs3/core-js-stable/object/define-properties\";\nimport _Object$defineProperty from \"@babel/runtime-corejs3/core-js-stable/object/define-property\";\nimport createEmotion from '@emotion/css/create-instance';\nimport PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport createCSSKey from '../createCSSKey';\nimport createDebug from '../utils/debug';\nimport EventSpy from '../EventSpy';\nimport FunctionContext from './FunctionContext';\nimport InternalContext from './InternalContext';\nimport SpineTo from '../SpineTo';\nimport State1Context from './State1Context';\nimport State2Context from './State2Context';\nimport StateContext from './StateContext';\nimport styleConsole from '../utils/styleConsole';\nimport useStateRef from '../hooks/internal/useStateRef';\nvar DEFAULT_SCROLLER = function DEFAULT_SCROLLER() {\n  return Infinity;\n};\nvar MIN_CHECK_INTERVAL = 17; // 1 frame\n\nvar MODE_BOTTOM = 'bottom';\nvar MODE_TOP = 'top';\nvar NEAR_END_THRESHOLD = 1;\nvar SCROLL_DECISION_DURATION = 34; // 2 frames\n// We pool the emotion object by nonce.\n// This is to make sure we don't generate too many unneeded <style> tags.\n\nvar emotionPool = {};\nfunction setImmediateInterval(fn, ms) {\n  fn();\n  return _setInterval(fn, ms);\n}\nfunction computeViewState(_ref) {\n  var mode = _ref.mode,\n    _ref$target = _ref.target,\n    offsetHeight = _ref$target.offsetHeight,\n    scrollHeight = _ref$target.scrollHeight,\n    scrollTop = _ref$target.scrollTop;\n  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  var atTop = scrollTop < NEAR_END_THRESHOLD;\n  var atEnd = mode === MODE_TOP ? atTop : atBottom;\n  var atStart = mode !== MODE_TOP ? atTop : atBottom;\n  return {\n    atBottom: atBottom,\n    atEnd: atEnd,\n    atStart: atStart,\n    atTop: atTop\n  };\n}\nfunction isEnd(animateTo, mode) {\n  return animateTo === (mode === MODE_TOP ? 0 : '100%');\n}\nvar Composer = function Composer(_ref2) {\n  var checkInterval = _ref2.checkInterval,\n    children = _ref2.children,\n    debounce = _ref2.debounce,\n    debugFromProp = _ref2.debug,\n    initialScrollBehavior = _ref2.initialScrollBehavior,\n    mode = _ref2.mode,\n    nonce = _ref2.nonce,\n    scroller = _ref2.scroller;\n  var debug = useMemo(function () {\n    return createDebug(\"<ScrollToBottom>\", {\n      force: debugFromProp\n    });\n  }, [debugFromProp]);\n  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;\n  var ignoreScrollEventBeforeRef = useRef(0);\n  var initialScrollBehaviorRef = useRef(initialScrollBehavior);\n  var _useStateRef = useStateRef(mode === MODE_TOP ? 0 : '100%'),\n    _useStateRef2 = _slicedToArray(_useStateRef, 3),\n    animateTo = _useStateRef2[0],\n    setAnimateTo = _useStateRef2[1],\n    animateToRef = _useStateRef2[2];\n  var _useStateRef3 = useStateRef(null),\n    _useStateRef4 = _slicedToArray(_useStateRef3, 3),\n    target = _useStateRef4[0],\n    setTarget = _useStateRef4[1],\n    targetRef = _useStateRef4[2]; // Internal context\n\n  var animateFromRef = useRef(0);\n  var offsetHeightRef = useRef(0);\n  var scrollHeightRef = useRef(0); // State context\n\n  var _useState = useState(true),\n    _useState2 = _slicedToArray(_useState, 2),\n    atBottom = _useState2[0],\n    setAtBottom = _useState2[1];\n  var _useState3 = useState(true),\n    _useState4 = _slicedToArray(_useState3, 2),\n    atEnd = _useState4[0],\n    setAtEnd = _useState4[1];\n  var _useState5 = useState(true),\n    _useState6 = _slicedToArray(_useState5, 2),\n    atTop = _useState6[0],\n    setAtTop = _useState6[1];\n  var _useState7 = useState(false),\n    _useState8 = _slicedToArray(_useState7, 2),\n    atStart = _useState8[0],\n    setAtStart = _useState8[1];\n  var _useStateRef5 = useStateRef(true),\n    _useStateRef6 = _slicedToArray(_useStateRef5, 3),\n    sticky = _useStateRef6[0],\n    setSticky = _useStateRef6[1],\n    stickyRef = _useStateRef6[2]; // High-rate state context\n\n  var scrollPositionObserversRef = useRef([]);\n  var observeScrollPosition = useCallback(function (fn) {\n    var target = targetRef.current;\n    scrollPositionObserversRef.current.push(fn);\n    target && fn({\n      scrollTop: target.scrollTop\n    });\n    return function () {\n      var scrollPositionObservers = scrollPositionObserversRef.current;\n      var index = _indexOfInstanceProperty(scrollPositionObservers).call(scrollPositionObservers, fn);\n      ~index && _spliceInstanceProperty(scrollPositionObservers).call(scrollPositionObservers, index, 1);\n    };\n  }, [scrollPositionObserversRef, targetRef]);\n  var handleSpineToEnd = useCallback(function () {\n    var animateTo = animateToRef.current;\n    debug(function () {\n      var _context;\n      return _concatInstanceProperty(_context = ['%cSpineTo%c: %conEnd%c is fired.']).call(_context, _toConsumableArray(styleConsole('magenta')), _toConsumableArray(styleConsole('orange')), [{\n        animateTo: animateTo\n      }]);\n    });\n    ignoreScrollEventBeforeRef.current = _Date$now(); // handleScrollEnd may end at a position which should lose stickiness.\n    // In that case, we will need to set sticky to false to stop the interval check.\n    // Test case:\n    // 1. Add a scroller that always return 0\n    // 2. Show a panel with mode === MODE_BOTTOM\n    // 3. Programmatically scroll to 0 (set element.scrollTop = 0)\n    // Expected: it should not repetitively call scrollTo(0)\n    //           it should set stickiness to false\n\n    isEnd(animateTo, mode) || setSticky(false);\n    setAnimateTo(null);\n  }, [animateToRef, debug, ignoreScrollEventBeforeRef, mode, setAnimateTo, setSticky]); // Function context\n\n  var scrollTo = useCallback(function (nextAnimateTo) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      behavior = _ref3.behavior;\n    var target = targetRef.current;\n    if (typeof nextAnimateTo !== 'number' && nextAnimateTo !== '100%') {\n      return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or \"100%\".');\n    } // If it is trying to scroll to a position which is not \"atEnd\", it should set sticky to false after scroll ended.\n\n    debug(function () {\n      var _context2;\n      return [_concatInstanceProperty(_context2 = [\"%cscrollTo%c: Will scroll to %c\".concat(typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/g, '%%'), \"%c\")]).call(_context2, _toConsumableArray(styleConsole('lime', '')), _toConsumableArray(styleConsole('purple'))), {\n        behavior: behavior,\n        nextAnimateTo: nextAnimateTo,\n        target: target\n      }];\n    });\n    if (behavior === 'auto') {\n      // Stop any existing animation\n      handleSpineToEnd();\n      if (target) {\n        // Jump to the scroll position\n        target.scrollTop = nextAnimateTo === '100%' ? target.scrollHeight - target.offsetHeight : nextAnimateTo;\n      }\n    } else {\n      behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollTo\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n      setAnimateTo(nextAnimateTo);\n    } // This is for handling a case. When calling scrollTo('100%', { behavior: 'auto' }) multiple times, it would lose stickiness.\n\n    if (isEnd(nextAnimateTo, mode)) {\n      debug(function () {\n        var _context3;\n        return [_concatInstanceProperty(_context3 = [\"%cscrollTo%c: Scrolling to end, will set sticky to %ctrue%c.\"]).call(_context3, _toConsumableArray(styleConsole('lime', '')), _toConsumableArray(styleConsole('purple'))), [{\n          mode: mode,\n          nextAnimateTo: nextAnimateTo\n        }]];\n      });\n      setSticky(true);\n    }\n  }, [debug, handleSpineToEnd, mode, setAnimateTo, setSticky, targetRef]);\n  var scrollToBottom = useCallback(function () {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      behavior = _ref4.behavior;\n    debug(function () {\n      var _context4;\n      return _concatInstanceProperty(_context4 = ['%cscrollToBottom%c: Called']).call(_context4, _toConsumableArray(styleConsole('yellow', '')));\n    });\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToBottom\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    scrollTo('100%', {\n      behavior: behavior || 'smooth'\n    });\n  }, [debug, scrollTo]);\n  var scrollToTop = useCallback(function () {\n    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      behavior = _ref5.behavior;\n    debug(function () {\n      var _context5;\n      return _concatInstanceProperty(_context5 = ['%cscrollToTop%c: Called']).call(_context5, _toConsumableArray(styleConsole('yellow', '')));\n    });\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToTop\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    scrollTo(0, {\n      behavior: behavior || 'smooth'\n    });\n  }, [debug, scrollTo]);\n  var scrollToEnd = useCallback(function () {\n    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      behavior = _ref6.behavior;\n    debug(function () {\n      var _context6;\n      return _concatInstanceProperty(_context6 = ['%cscrollToEnd%c: Called']).call(_context6, _toConsumableArray(styleConsole('yellow', '')));\n    });\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToEnd\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    var options = {\n      behavior: behavior || 'smooth'\n    };\n    mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);\n  }, [debug, mode, scrollToBottom, scrollToTop]);\n  var scrollToStart = useCallback(function () {\n    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      behavior = _ref7.behavior;\n    debug(function () {\n      var _context7;\n      return _concatInstanceProperty(_context7 = ['%cscrollToStart%c: Called']).call(_context7, _toConsumableArray(styleConsole('yellow', '')));\n    });\n    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToStart\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');\n    var options = {\n      behavior: behavior || 'smooth'\n    };\n    mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);\n  }, [debug, mode, scrollToBottom, scrollToTop]);\n  var scrollToSticky = useCallback(function () {\n    var target = targetRef.current;\n    if (target) {\n      if (initialScrollBehaviorRef.current === 'auto') {\n        debug(function () {\n          var _context8;\n          return _concatInstanceProperty(_context8 = [\"%ctarget changed%c: Initial scroll\"]).call(_context8, _toConsumableArray(styleConsole('blue')));\n        });\n        target.scrollTop = mode === MODE_TOP ? 0 : target.scrollHeight - target.offsetHeight;\n        initialScrollBehaviorRef.current = false;\n        return;\n      } // This is very similar to scrollToEnd().\n      // Instead of scrolling to end, it will call props.scroller() to determines how far it should scroll.\n      // This function could be called while it is auto-scrolling.\n\n      var animateFrom = animateFromRef.current;\n      var offsetHeight = target.offsetHeight,\n        scrollHeight = target.scrollHeight,\n        scrollTop = target.scrollTop;\n      var maxValue = mode === MODE_TOP ? 0 : Math.max(0, scrollHeight - offsetHeight - scrollTop);\n      var minValue = Math.max(0, animateFrom - scrollTop);\n      var rawNextValue = scroller({\n        maxValue: maxValue,\n        minValue: minValue,\n        offsetHeight: offsetHeight,\n        scrollHeight: scrollHeight,\n        scrollTop: scrollTop\n      });\n      var nextValue = Math.max(0, Math.min(maxValue, rawNextValue));\n      var nextAnimateTo;\n      if (mode === MODE_TOP || nextValue !== maxValue) {\n        nextAnimateTo = scrollTop + nextValue;\n      } else {\n        // When scrolling to bottom, we should scroll to \"100%\".\n        // Otherwise, if we scroll to any number, it will lose stickiness when elements are adding too fast.\n        // \"100%\" is a special argument intended to make sure stickiness is not lost while new elements are being added.\n        nextAnimateTo = '100%';\n      }\n      debug(function () {\n        var _context9, _context10, _context11;\n        return [_concatInstanceProperty(_context9 = [_concatInstanceProperty(_context10 = _concatInstanceProperty(_context11 = \"%cscrollToSticky%c: Will animate from %c\".concat(animateFrom, \"px%c to %c\")).call(_context11, typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/g, '%%'), \"%c (%c\")).call(_context10, (nextAnimateTo === '100%' ? maxValue : nextAnimateTo) + animateFrom, \"px%c)\")]).call(_context9, _toConsumableArray(styleConsole('orange')), _toConsumableArray(styleConsole('purple')), _toConsumableArray(styleConsole('purple')), _toConsumableArray(styleConsole('purple'))), {\n          animateFrom: animateFrom,\n          maxValue: maxValue,\n          minValue: minValue,\n          nextAnimateTo: nextAnimateTo,\n          nextValue: nextValue,\n          offsetHeight: offsetHeight,\n          rawNextValue: rawNextValue,\n          scrollHeight: scrollHeight,\n          scrollTop: scrollTop\n        }];\n      });\n      scrollTo(nextAnimateTo, {\n        behavior: 'smooth'\n      });\n    }\n  }, [animateFromRef, debug, mode, scroller, scrollTo, targetRef]);\n  var handleScroll = useCallback(function (_ref8) {\n    var _context17;\n    var timeStampLow = _ref8.timeStampLow;\n    var animateTo = animateToRef.current;\n    var target = targetRef.current;\n    var animating = animateTo !== null; // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n    // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n    if (timeStampLow <= ignoreScrollEventBeforeRef.current || !target) {\n      // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n      // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n      return;\n    }\n    var _computeViewState = computeViewState({\n        mode: mode,\n        target: target\n      }),\n      atBottom = _computeViewState.atBottom,\n      atEnd = _computeViewState.atEnd,\n      atStart = _computeViewState.atStart,\n      atTop = _computeViewState.atTop;\n    setAtBottom(atBottom);\n    setAtEnd(atEnd);\n    setAtStart(atStart);\n    setAtTop(atTop); // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n    // We need to ignore these \"synthetic\" events\n    // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n    //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom\n\n    var nextOffsetHeight = target.offsetHeight,\n      nextScrollHeight = target.scrollHeight;\n    var offsetHeight = offsetHeightRef.current;\n    var scrollHeight = scrollHeightRef.current;\n    var offsetHeightChanged = nextOffsetHeight !== offsetHeight;\n    var scrollHeightChanged = nextScrollHeight !== scrollHeight;\n    if (offsetHeightChanged) {\n      offsetHeightRef.current = nextOffsetHeight;\n    }\n    if (scrollHeightChanged) {\n      scrollHeightRef.current = nextScrollHeight;\n    } // Sticky means:\n    // - If it is scrolled programatically, we are still in sticky mode\n    // - If it is scrolled by the user, then sticky means if we are at the end\n    // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n\n    if (!offsetHeightChanged && !scrollHeightChanged) {\n      // We are sticky if we are animating to the end, or we are already at the end.\n      // We can be \"animating but not sticky\" by calling \"scrollTo(100)\" where the container scrollHeight is 200px.\n      var nextSticky = animating && isEnd(animateTo, mode) || atEnd;\n      if (stickyRef.current !== nextSticky) {\n        debug(function () {\n          var _context12, _context13, _context14, _context15;\n          return [_concatInstanceProperty(_context12 = [\"%conScroll%c: %csetSticky%c(%c\".concat(nextSticky, \"%c)\")]).call(_context12, _toConsumableArray(styleConsole('red')), _toConsumableArray(styleConsole('red')), _toConsumableArray(styleConsole('purple'))), _concatInstanceProperty(_context13 = [_concatInstanceProperty(_context14 = _concatInstanceProperty(_context15 = \"(animating = %c\".concat(animating, \"%c && isEnd = %c\")).call(_context15, isEnd(animateTo, mode), \"%c) || atEnd = %c\")).call(_context14, atEnd, \"%c\")]).call(_context13, _toConsumableArray(styleConsole('purple')), _toConsumableArray(styleConsole('purple')), _toConsumableArray(styleConsole('purple')), [{\n            animating: animating,\n            animateTo: animateTo,\n            atEnd: atEnd,\n            mode: mode,\n            offsetHeight: target.offsetHeight,\n            scrollHeight: target.scrollHeight,\n            sticky: stickyRef.current,\n            nextSticky: nextSticky\n          }])];\n        });\n        setSticky(nextSticky);\n      }\n    } else if (stickyRef.current) {\n      debug(function () {\n        var _context16;\n        return [_concatInstanceProperty(_context16 = [\"%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c\"]).call(_context16, _toConsumableArray(styleConsole('red')), _toConsumableArray(styleConsole('orange')), [{\n          offsetHeightChanged: offsetHeightChanged,\n          scrollHeightChanged: scrollHeightChanged\n        }]), {\n          nextOffsetHeight: nextOffsetHeight,\n          prevOffsetHeight: offsetHeight,\n          nextScrollHeight: nextScrollHeight,\n          prevScrollHeight: scrollHeight\n        }];\n      });\n      scrollToSticky();\n    }\n    var actualScrollTop = target.scrollTop;\n    _forEachInstanceProperty(_context17 = scrollPositionObserversRef.current).call(_context17, function (observer) {\n      return observer({\n        scrollTop: actualScrollTop\n      });\n    });\n  }, [animateToRef, debug, ignoreScrollEventBeforeRef, mode, offsetHeightRef, scrollHeightRef, scrollPositionObserversRef, scrollToSticky, setAtBottom, setAtEnd, setAtStart, setAtTop, setSticky, stickyRef, targetRef]);\n  useEffect(function () {\n    if (target) {\n      var stickyButNotAtEndSince = false;\n      var timeout = setImmediateInterval(function () {\n        var target = targetRef.current;\n        var animating = animateToRef.current !== null;\n        if (stickyRef.current) {\n          if (!computeViewState({\n            mode: mode,\n            target: target\n          }).atEnd) {\n            if (!stickyButNotAtEndSince) {\n              stickyButNotAtEndSince = _Date$now();\n            } else if (_Date$now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n              // Quirks: In Firefox, after user scroll down, Firefox do two things:\n              //         1. Set to a new \"scrollTop\"\n              //         2. Fire \"scroll\" event\n              //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n              //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n              // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n              // The \"animating\" check will make sure stickiness is not lost when elements are adding at a very fast pace.\n              if (!animating) {\n                animateFromRef.current = target.scrollTop;\n                debug(function () {\n                  var _context18;\n                  return _concatInstanceProperty(_context18 = [\"%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll\"]).call(_context18, _toConsumableArray(styleConsole('navy')), _toConsumableArray(styleConsole('orange')));\n                });\n                scrollToSticky();\n              }\n              stickyButNotAtEndSince = false;\n            }\n          } else {\n            stickyButNotAtEndSince = false;\n          }\n        } else if (target.scrollHeight <= target.offsetHeight && !stickyRef.current) {\n          // When the container is emptied, we will set sticky back to true.\n          debug(function () {\n            var _context19;\n            return [_concatInstanceProperty(_context19 = [\"%cInterval check%c: Container is emptied, setting sticky back to %ctrue%c\"]).call(_context19, _toConsumableArray(styleConsole('navy')), _toConsumableArray(styleConsole('purple'))), [{\n              offsetHeight: target.offsetHeight,\n              scrollHeight: target.scrollHeight,\n              sticky: stickyRef.current\n            }]];\n          });\n          setSticky(true);\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);\n      return function () {\n        return clearInterval(timeout);\n      };\n    }\n  }, [animateToRef, checkInterval, debug, mode, scrollToSticky, setSticky, stickyRef, target, targetRef]);\n  var styleToClassName = useMemo(function () {\n    var emotion = emotionPool[nonce] || (emotionPool[nonce] = createEmotion({\n      key: 'react-scroll-to-bottom--css-' + createCSSKey(),\n      nonce: nonce\n    }));\n    return function (style) {\n      return emotion.css(style) + '';\n    };\n  }, [nonce]);\n  var internalContext = useMemo(function () {\n    return {\n      observeScrollPosition: observeScrollPosition,\n      setTarget: setTarget,\n      styleToClassName: styleToClassName\n    };\n  }, [observeScrollPosition, setTarget, styleToClassName]);\n  var state1Context = useMemo(function () {\n    return {\n      atBottom: atBottom,\n      atEnd: atEnd,\n      atStart: atStart,\n      atTop: atTop,\n      mode: mode\n    };\n  }, [atBottom, atEnd, atStart, atTop, mode]);\n  var state2Context = useMemo(function () {\n    var animating = animateTo !== null;\n    return {\n      animating: animating,\n      animatingToEnd: animating && isEnd(animateTo, mode),\n      sticky: sticky\n    };\n  }, [animateTo, mode, sticky]);\n  var combinedStateContext = useMemo(function () {\n    return _objectSpread(_objectSpread({}, state1Context), state2Context);\n  }, [state1Context, state2Context]);\n  var functionContext = useMemo(function () {\n    return {\n      scrollTo: scrollTo,\n      scrollToBottom: scrollToBottom,\n      scrollToEnd: scrollToEnd,\n      scrollToStart: scrollToStart,\n      scrollToTop: scrollToTop\n    };\n  }, [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]);\n  useEffect(function () {\n    // We need to update the \"scrollHeight\" value to latest when the user do a focus inside the box.\n    //\n    // This is because:\n    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether \"scrollHeight\" value is latest or not.\n    // - That code only run on \"scroll\" event.\n    // - That means, on every \"scroll\" event, if the \"scrollHeight\" value is not latest, we will skip modifying the stickiness.\n    // - That means, if the user \"focus\" to an element that cause the scroll view to scroll to the bottom, the user agent will fire \"scroll\" event.\n    //   Since the \"scrollHeight\" is not latest value, this \"scroll\" event will be ignored and stickiness will not be modified.\n    // - That means, if the user \"focus\" to a newly added element that is at the end of the scroll view, the \"scroll to bottom\" button will continue to show.\n    //\n    // Repro in Chrome:\n    // 1. Fill up a scroll view\n    // 2. Scroll up, the \"scroll to bottom\" button should show up\n    // 3. Click \"Add a button\"\n    // 4. Click on the scroll view (to pseudo-focus on it)\n    // 5. Press TAB, the scroll view will be at the bottom\n    //\n    // Expect:\n    // - The \"scroll to bottom\" button should be gone.\n    if (target) {\n      var handleFocus = function handleFocus() {\n        scrollHeightRef.current = target.scrollHeight;\n      };\n      target.addEventListener('focus', handleFocus, {\n        capture: true,\n        passive: true\n      });\n      return function () {\n        return target.removeEventListener('focus', handleFocus);\n      };\n    }\n  }, [target]);\n  debug(function () {\n    var _context20;\n    return [_concatInstanceProperty(_context20 = [\"%cRender%c: Render\"]).call(_context20, _toConsumableArray(styleConsole('cyan', ''))), {\n      animateTo: animateTo,\n      animating: animateTo !== null,\n      sticky: sticky,\n      target: target\n    }];\n  });\n  return /*#__PURE__*/React.createElement(InternalContext.Provider, {\n    value: internalContext\n  }, /*#__PURE__*/React.createElement(FunctionContext.Provider, {\n    value: functionContext\n  }, /*#__PURE__*/React.createElement(StateContext.Provider, {\n    value: combinedStateContext\n  }, /*#__PURE__*/React.createElement(State1Context.Provider, {\n    value: state1Context\n  }, /*#__PURE__*/React.createElement(State2Context.Provider, {\n    value: state2Context\n  }, children, target && /*#__PURE__*/React.createElement(EventSpy, {\n    debounce: debounce,\n    name: \"scroll\",\n    onEvent: handleScroll,\n    target: target\n  }), target && animateTo !== null && /*#__PURE__*/React.createElement(SpineTo, {\n    name: \"scrollTop\",\n    onEnd: handleSpineToEnd,\n    target: target,\n    value: animateTo\n  }))))));\n};\nComposer.defaultProps = {\n  checkInterval: 100,\n  children: undefined,\n  debounce: 17,\n  debug: undefined,\n  initialScrollBehavior: 'smooth',\n  mode: undefined,\n  nonce: undefined,\n  scroller: DEFAULT_SCROLLER\n};\nComposer.propTypes = {\n  checkInterval: PropTypes.number,\n  children: PropTypes.any,\n  debounce: PropTypes.number,\n  debug: PropTypes.bool,\n  initialScrollBehavior: PropTypes.oneOf(['auto', 'smooth']),\n  mode: PropTypes.oneOf(['bottom', 'top']),\n  nonce: PropTypes.string,\n  scroller: PropTypes.func\n};\nexport default Composer;","map":{"version":3,"names":["createEmotion","PropTypes","React","useCallback","useEffect","useMemo","useRef","useState","createCSSKey","createDebug","EventSpy","FunctionContext","InternalContext","SpineTo","State1Context","State2Context","StateContext","styleConsole","useStateRef","DEFAULT_SCROLLER","Infinity","MIN_CHECK_INTERVAL","MODE_BOTTOM","MODE_TOP","NEAR_END_THRESHOLD","SCROLL_DECISION_DURATION","emotionPool","setImmediateInterval","fn","ms","_setInterval","computeViewState","_ref","mode","_ref$target","target","offsetHeight","scrollHeight","scrollTop","atBottom","atTop","atEnd","atStart","isEnd","animateTo","Composer","_ref2","checkInterval","children","debounce","debugFromProp","debug","initialScrollBehavior","nonce","scroller","force","ignoreScrollEventBeforeRef","initialScrollBehaviorRef","_useStateRef","_useStateRef2","_slicedToArray","setAnimateTo","animateToRef","_useStateRef3","_useStateRef4","setTarget","targetRef","animateFromRef","offsetHeightRef","scrollHeightRef","_useState","_useState2","setAtBottom","_useState3","_useState4","setAtEnd","_useState5","_useState6","setAtTop","_useState7","_useState8","setAtStart","_useStateRef5","_useStateRef6","sticky","setSticky","stickyRef","scrollPositionObserversRef","observeScrollPosition","current","push","scrollPositionObservers","index","_indexOfInstanceProperty","call","_spliceInstanceProperty","handleSpineToEnd","_context","_concatInstanceProperty","_toConsumableArray","_Date$now","scrollTo","nextAnimateTo","_ref3","arguments","length","undefined","behavior","console","warn","_context2","concat","replace","_context3","scrollToBottom","_ref4","_context4","scrollToTop","_ref5","_context5","scrollToEnd","_ref6","_context6","options","scrollToStart","_ref7","_context7","scrollToSticky","_context8","animateFrom","maxValue","Math","max","minValue","rawNextValue","nextValue","min","_context9","_context10","_context11","handleScroll","_ref8","_context17","timeStampLow","animating","_computeViewState","nextOffsetHeight","nextScrollHeight","offsetHeightChanged","scrollHeightChanged","nextSticky","_context12","_context13","_context14","_context15","_context16","prevOffsetHeight","prevScrollHeight","actualScrollTop","_forEachInstanceProperty","observer","stickyButNotAtEndSince","timeout","_context18","_context19","clearInterval","styleToClassName","emotion","key","style","css","internalContext","state1Context","state2Context","animatingToEnd","combinedStateContext","_objectSpread","functionContext","handleFocus","addEventListener","capture","passive","removeEventListener","_context20","createElement","Provider","value","name","onEvent","onEnd","defaultProps","propTypes","number","any","bool","oneOf","string","func"],"sources":["C:\\Users\\ernes\\OneDrive\\Documents\\COMPX241 Labs\\COMPX241 - Blowing in the wind\\BlowingInTheWind\\client\\node_modules\\react-scroll-to-bottom\\src\\ScrollToBottom\\Composer.js"],"sourcesContent":["import createEmotion from '@emotion/css/create-instance';\nimport PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport createCSSKey from '../createCSSKey';\nimport createDebug from '../utils/debug';\nimport EventSpy from '../EventSpy';\nimport FunctionContext from './FunctionContext';\nimport InternalContext from './InternalContext';\nimport SpineTo from '../SpineTo';\nimport State1Context from './State1Context';\nimport State2Context from './State2Context';\nimport StateContext from './StateContext';\nimport styleConsole from '../utils/styleConsole';\nimport useStateRef from '../hooks/internal/useStateRef';\n\nconst DEFAULT_SCROLLER = () => Infinity;\nconst MIN_CHECK_INTERVAL = 17; // 1 frame\nconst MODE_BOTTOM = 'bottom';\nconst MODE_TOP = 'top';\nconst NEAR_END_THRESHOLD = 1;\nconst SCROLL_DECISION_DURATION = 34; // 2 frames\n\n// We pool the emotion object by nonce.\n// This is to make sure we don't generate too many unneeded <style> tags.\nconst emotionPool = {};\n\nfunction setImmediateInterval(fn, ms) {\n  fn();\n\n  return setInterval(fn, ms);\n}\n\nfunction computeViewState({ mode, target: { offsetHeight, scrollHeight, scrollTop } }) {\n  const atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;\n  const atTop = scrollTop < NEAR_END_THRESHOLD;\n\n  const atEnd = mode === MODE_TOP ? atTop : atBottom;\n  const atStart = mode !== MODE_TOP ? atTop : atBottom;\n\n  return {\n    atBottom,\n    atEnd,\n    atStart,\n    atTop\n  };\n}\n\nfunction isEnd(animateTo, mode) {\n  return animateTo === (mode === MODE_TOP ? 0 : '100%');\n}\n\nconst Composer = ({\n  checkInterval,\n  children,\n  debounce,\n  debug: debugFromProp,\n  initialScrollBehavior,\n  mode,\n  nonce,\n  scroller\n}) => {\n  const debug = useMemo(() => createDebug(`<ScrollToBottom>`, { force: debugFromProp }), [debugFromProp]);\n\n  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;\n\n  const ignoreScrollEventBeforeRef = useRef(0);\n  const initialScrollBehaviorRef = useRef(initialScrollBehavior);\n  const [animateTo, setAnimateTo, animateToRef] = useStateRef(mode === MODE_TOP ? 0 : '100%');\n  const [target, setTarget, targetRef] = useStateRef(null);\n\n  // Internal context\n  const animateFromRef = useRef(0);\n  const offsetHeightRef = useRef(0);\n  const scrollHeightRef = useRef(0);\n\n  // State context\n  const [atBottom, setAtBottom] = useState(true);\n  const [atEnd, setAtEnd] = useState(true);\n  const [atTop, setAtTop] = useState(true);\n  const [atStart, setAtStart] = useState(false);\n  const [sticky, setSticky, stickyRef] = useStateRef(true);\n\n  // High-rate state context\n  const scrollPositionObserversRef = useRef([]);\n  const observeScrollPosition = useCallback(\n    fn => {\n      const { current: target } = targetRef;\n\n      scrollPositionObserversRef.current.push(fn);\n      target && fn({ scrollTop: target.scrollTop });\n\n      return () => {\n        const { current: scrollPositionObservers } = scrollPositionObserversRef;\n        const index = scrollPositionObservers.indexOf(fn);\n\n        ~index && scrollPositionObservers.splice(index, 1);\n      };\n    },\n    [scrollPositionObserversRef, targetRef]\n  );\n\n  const handleSpineToEnd = useCallback(() => {\n    const { current: animateTo } = animateToRef;\n\n    debug(() => [\n      '%cSpineTo%c: %conEnd%c is fired.',\n      ...styleConsole('magenta'),\n      ...styleConsole('orange'),\n      { animateTo }\n    ]);\n\n    ignoreScrollEventBeforeRef.current = Date.now();\n\n    // handleScrollEnd may end at a position which should lose stickiness.\n    // In that case, we will need to set sticky to false to stop the interval check.\n    // Test case:\n    // 1. Add a scroller that always return 0\n    // 2. Show a panel with mode === MODE_BOTTOM\n    // 3. Programmatically scroll to 0 (set element.scrollTop = 0)\n    // Expected: it should not repetitively call scrollTo(0)\n    //           it should set stickiness to false\n\n    isEnd(animateTo, mode) || setSticky(false);\n    setAnimateTo(null);\n  }, [animateToRef, debug, ignoreScrollEventBeforeRef, mode, setAnimateTo, setSticky]);\n\n  // Function context\n  const scrollTo = useCallback(\n    (nextAnimateTo, { behavior } = {}) => {\n      const { current: target } = targetRef;\n\n      if (typeof nextAnimateTo !== 'number' && nextAnimateTo !== '100%') {\n        return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or \"100%\".');\n      }\n\n      // If it is trying to scroll to a position which is not \"atEnd\", it should set sticky to false after scroll ended.\n\n      debug(() => [\n        [\n          `%cscrollTo%c: Will scroll to %c${\n            typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/gu, '%%')\n          }%c`,\n          ...styleConsole('lime', ''),\n          ...styleConsole('purple')\n        ],\n        {\n          behavior,\n          nextAnimateTo,\n          target\n        }\n      ]);\n\n      if (behavior === 'auto') {\n        // Stop any existing animation\n        handleSpineToEnd();\n\n        if (target) {\n          // Jump to the scroll position\n          target.scrollTop = nextAnimateTo === '100%' ? target.scrollHeight - target.offsetHeight : nextAnimateTo;\n        }\n      } else {\n        behavior !== 'smooth' &&\n          console.warn(\n            'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollTo\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n          );\n\n        setAnimateTo(nextAnimateTo);\n      }\n\n      // This is for handling a case. When calling scrollTo('100%', { behavior: 'auto' }) multiple times, it would lose stickiness.\n      if (isEnd(nextAnimateTo, mode)) {\n        debug(() => [\n          [\n            `%cscrollTo%c: Scrolling to end, will set sticky to %ctrue%c.`,\n            ...styleConsole('lime', ''),\n            ...styleConsole('purple')\n          ],\n          [{ mode, nextAnimateTo }]\n        ]);\n\n        setSticky(true);\n      }\n    },\n    [debug, handleSpineToEnd, mode, setAnimateTo, setSticky, targetRef]\n  );\n\n  const scrollToBottom = useCallback(\n    ({ behavior } = {}) => {\n      debug(() => ['%cscrollToBottom%c: Called', ...styleConsole('yellow', '')]);\n\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToBottom\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      scrollTo('100%', { behavior: behavior || 'smooth' });\n    },\n    [debug, scrollTo]\n  );\n\n  const scrollToTop = useCallback(\n    ({ behavior } = {}) => {\n      debug(() => ['%cscrollToTop%c: Called', ...styleConsole('yellow', '')]);\n\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToTop\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      scrollTo(0, { behavior: behavior || 'smooth' });\n    },\n    [debug, scrollTo]\n  );\n\n  const scrollToEnd = useCallback(\n    ({ behavior } = {}) => {\n      debug(() => ['%cscrollToEnd%c: Called', ...styleConsole('yellow', '')]);\n\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToEnd\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      const options = { behavior: behavior || 'smooth' };\n\n      mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);\n    },\n    [debug, mode, scrollToBottom, scrollToTop]\n  );\n\n  const scrollToStart = useCallback(\n    ({ behavior } = {}) => {\n      debug(() => ['%cscrollToStart%c: Called', ...styleConsole('yellow', '')]);\n\n      behavior !== 'smooth' &&\n        console.warn(\n          'react-scroll-to-bottom: Please set \"behavior\" when calling \"scrollToStart\". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'\n        );\n\n      const options = { behavior: behavior || 'smooth' };\n\n      mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);\n    },\n    [debug, mode, scrollToBottom, scrollToTop]\n  );\n\n  const scrollToSticky = useCallback(() => {\n    const { current: target } = targetRef;\n\n    if (target) {\n      if (initialScrollBehaviorRef.current === 'auto') {\n        debug(() => [`%ctarget changed%c: Initial scroll`, ...styleConsole('blue')]);\n\n        target.scrollTop = mode === MODE_TOP ? 0 : target.scrollHeight - target.offsetHeight;\n        initialScrollBehaviorRef.current = false;\n\n        return;\n      }\n\n      // This is very similar to scrollToEnd().\n      // Instead of scrolling to end, it will call props.scroller() to determines how far it should scroll.\n      // This function could be called while it is auto-scrolling.\n\n      const { current: animateFrom } = animateFromRef;\n      const { offsetHeight, scrollHeight, scrollTop } = target;\n\n      const maxValue = mode === MODE_TOP ? 0 : Math.max(0, scrollHeight - offsetHeight - scrollTop);\n      const minValue = Math.max(0, animateFrom - scrollTop);\n\n      const rawNextValue = scroller({ maxValue, minValue, offsetHeight, scrollHeight, scrollTop });\n\n      const nextValue = Math.max(0, Math.min(maxValue, rawNextValue));\n\n      let nextAnimateTo;\n\n      if (mode === MODE_TOP || nextValue !== maxValue) {\n        nextAnimateTo = scrollTop + nextValue;\n      } else {\n        // When scrolling to bottom, we should scroll to \"100%\".\n        // Otherwise, if we scroll to any number, it will lose stickiness when elements are adding too fast.\n        // \"100%\" is a special argument intended to make sure stickiness is not lost while new elements are being added.\n        nextAnimateTo = '100%';\n      }\n\n      debug(() => [\n        [\n          `%cscrollToSticky%c: Will animate from %c${animateFrom}px%c to %c${\n            typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/gu, '%%')\n          }%c (%c${(nextAnimateTo === '100%' ? maxValue : nextAnimateTo) + animateFrom}px%c)`,\n          ...styleConsole('orange'),\n          ...styleConsole('purple'),\n          ...styleConsole('purple'),\n          ...styleConsole('purple')\n        ],\n        {\n          animateFrom,\n          maxValue,\n          minValue,\n          nextAnimateTo,\n          nextValue,\n          offsetHeight,\n          rawNextValue,\n          scrollHeight,\n          scrollTop\n        }\n      ]);\n\n      scrollTo(nextAnimateTo, { behavior: 'smooth' });\n    }\n  }, [animateFromRef, debug, mode, scroller, scrollTo, targetRef]);\n\n  const handleScroll = useCallback(\n    ({ timeStampLow }) => {\n      const { current: animateTo } = animateToRef;\n      const { current: target } = targetRef;\n\n      const animating = animateTo !== null;\n\n      // Currently, there are no reliable way to check if the \"scroll\" event is trigger due to\n      // user gesture, programmatic scrolling, or Chrome-synthesized \"scroll\" event to compensate size change.\n      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.\n\n      if (timeStampLow <= ignoreScrollEventBeforeRef.current || !target) {\n        // Since we debounce \"scroll\" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).\n        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.\n        // Thus, on a fast machine, adding elements super fast will lose the \"stickiness\".\n\n        return;\n      }\n\n      const { atBottom, atEnd, atStart, atTop } = computeViewState({ mode, target });\n\n      setAtBottom(atBottom);\n      setAtEnd(atEnd);\n      setAtStart(atStart);\n      setAtTop(atTop);\n\n      // Chrome will emit \"synthetic\" scroll event if the container is resized or an element is added\n      // We need to ignore these \"synthetic\" events\n      // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)\n      //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom\n      const { offsetHeight: nextOffsetHeight, scrollHeight: nextScrollHeight } = target;\n      const { current: offsetHeight } = offsetHeightRef;\n      const { current: scrollHeight } = scrollHeightRef;\n      const offsetHeightChanged = nextOffsetHeight !== offsetHeight;\n      const scrollHeightChanged = nextScrollHeight !== scrollHeight;\n\n      if (offsetHeightChanged) {\n        offsetHeightRef.current = nextOffsetHeight;\n      }\n\n      if (scrollHeightChanged) {\n        scrollHeightRef.current = nextScrollHeight;\n      }\n\n      // Sticky means:\n      // - If it is scrolled programatically, we are still in sticky mode\n      // - If it is scrolled by the user, then sticky means if we are at the end\n\n      // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome\n      if (!offsetHeightChanged && !scrollHeightChanged) {\n        // We are sticky if we are animating to the end, or we are already at the end.\n        // We can be \"animating but not sticky\" by calling \"scrollTo(100)\" where the container scrollHeight is 200px.\n        const nextSticky = (animating && isEnd(animateTo, mode)) || atEnd;\n\n        if (stickyRef.current !== nextSticky) {\n          debug(() => [\n            [\n              `%conScroll%c: %csetSticky%c(%c${nextSticky}%c)`,\n              ...styleConsole('red'),\n              ...styleConsole('red'),\n              ...styleConsole('purple')\n            ],\n            [\n              `(animating = %c${animating}%c && isEnd = %c${isEnd(animateTo, mode)}%c) || atEnd = %c${atEnd}%c`,\n              ...styleConsole('purple'),\n              ...styleConsole('purple'),\n              ...styleConsole('purple'),\n              {\n                animating,\n                animateTo,\n                atEnd,\n                mode,\n                offsetHeight: target.offsetHeight,\n                scrollHeight: target.scrollHeight,\n                sticky: stickyRef.current,\n                nextSticky\n              }\n            ]\n          ]);\n\n          setSticky(nextSticky);\n        }\n      } else if (stickyRef.current) {\n        debug(() => [\n          [\n            `%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c`,\n            ...styleConsole('red'),\n            ...styleConsole('orange'),\n            {\n              offsetHeightChanged,\n              scrollHeightChanged\n            }\n          ],\n          {\n            nextOffsetHeight,\n            prevOffsetHeight: offsetHeight,\n            nextScrollHeight,\n            prevScrollHeight: scrollHeight\n          }\n        ]);\n\n        scrollToSticky();\n      }\n\n      const { scrollTop: actualScrollTop } = target;\n\n      scrollPositionObserversRef.current.forEach(observer => observer({ scrollTop: actualScrollTop }));\n    },\n    [\n      animateToRef,\n      debug,\n      ignoreScrollEventBeforeRef,\n      mode,\n      offsetHeightRef,\n      scrollHeightRef,\n      scrollPositionObserversRef,\n      scrollToSticky,\n      setAtBottom,\n      setAtEnd,\n      setAtStart,\n      setAtTop,\n      setSticky,\n      stickyRef,\n      targetRef\n    ]\n  );\n\n  useEffect(() => {\n    if (target) {\n      let stickyButNotAtEndSince = false;\n\n      const timeout = setImmediateInterval(() => {\n        const { current: target } = targetRef;\n        const animating = animateToRef.current !== null;\n\n        if (stickyRef.current) {\n          if (!computeViewState({ mode, target }).atEnd) {\n            if (!stickyButNotAtEndSince) {\n              stickyButNotAtEndSince = Date.now();\n            } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {\n              // Quirks: In Firefox, after user scroll down, Firefox do two things:\n              //         1. Set to a new \"scrollTop\"\n              //         2. Fire \"scroll\" event\n              //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.\n              //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.\n              // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.\n\n              // The \"animating\" check will make sure stickiness is not lost when elements are adding at a very fast pace.\n              if (!animating) {\n                animateFromRef.current = target.scrollTop;\n\n                debug(() => [\n                  `%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll`,\n                  ...styleConsole('navy'),\n                  ...styleConsole('orange')\n                ]);\n\n                scrollToSticky();\n              }\n\n              stickyButNotAtEndSince = false;\n            }\n          } else {\n            stickyButNotAtEndSince = false;\n          }\n        } else if (target.scrollHeight <= target.offsetHeight && !stickyRef.current) {\n          // When the container is emptied, we will set sticky back to true.\n\n          debug(() => [\n            [\n              `%cInterval check%c: Container is emptied, setting sticky back to %ctrue%c`,\n              ...styleConsole('navy'),\n              ...styleConsole('purple')\n            ],\n            [\n              {\n                offsetHeight: target.offsetHeight,\n                scrollHeight: target.scrollHeight,\n                sticky: stickyRef.current\n              }\n            ]\n          ]);\n\n          setSticky(true);\n        }\n      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);\n\n      return () => clearInterval(timeout);\n    }\n  }, [animateToRef, checkInterval, debug, mode, scrollToSticky, setSticky, stickyRef, target, targetRef]);\n\n  const styleToClassName = useMemo(() => {\n    const emotion =\n      emotionPool[nonce] ||\n      (emotionPool[nonce] = createEmotion({ key: 'react-scroll-to-bottom--css-' + createCSSKey(), nonce }));\n\n    return style => emotion.css(style) + '';\n  }, [nonce]);\n\n  const internalContext = useMemo(\n    () => ({\n      observeScrollPosition,\n      setTarget,\n      styleToClassName\n    }),\n    [observeScrollPosition, setTarget, styleToClassName]\n  );\n\n  const state1Context = useMemo(\n    () => ({\n      atBottom,\n      atEnd,\n      atStart,\n      atTop,\n      mode\n    }),\n    [atBottom, atEnd, atStart, atTop, mode]\n  );\n\n  const state2Context = useMemo(() => {\n    const animating = animateTo !== null;\n\n    return {\n      animating,\n      animatingToEnd: animating && isEnd(animateTo, mode),\n      sticky\n    };\n  }, [animateTo, mode, sticky]);\n\n  const combinedStateContext = useMemo(\n    () => ({\n      ...state1Context,\n      ...state2Context\n    }),\n    [state1Context, state2Context]\n  );\n\n  const functionContext = useMemo(\n    () => ({\n      scrollTo,\n      scrollToBottom,\n      scrollToEnd,\n      scrollToStart,\n      scrollToTop\n    }),\n    [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]\n  );\n\n  useEffect(() => {\n    // We need to update the \"scrollHeight\" value to latest when the user do a focus inside the box.\n    //\n    // This is because:\n    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether \"scrollHeight\" value is latest or not.\n    // - That code only run on \"scroll\" event.\n    // - That means, on every \"scroll\" event, if the \"scrollHeight\" value is not latest, we will skip modifying the stickiness.\n    // - That means, if the user \"focus\" to an element that cause the scroll view to scroll to the bottom, the user agent will fire \"scroll\" event.\n    //   Since the \"scrollHeight\" is not latest value, this \"scroll\" event will be ignored and stickiness will not be modified.\n    // - That means, if the user \"focus\" to a newly added element that is at the end of the scroll view, the \"scroll to bottom\" button will continue to show.\n    //\n    // Repro in Chrome:\n    // 1. Fill up a scroll view\n    // 2. Scroll up, the \"scroll to bottom\" button should show up\n    // 3. Click \"Add a button\"\n    // 4. Click on the scroll view (to pseudo-focus on it)\n    // 5. Press TAB, the scroll view will be at the bottom\n    //\n    // Expect:\n    // - The \"scroll to bottom\" button should be gone.\n    if (target) {\n      const handleFocus = () => {\n        scrollHeightRef.current = target.scrollHeight;\n      };\n\n      target.addEventListener('focus', handleFocus, { capture: true, passive: true });\n\n      return () => target.removeEventListener('focus', handleFocus);\n    }\n  }, [target]);\n\n  debug(() => [\n    [`%cRender%c: Render`, ...styleConsole('cyan', '')],\n    {\n      animateTo,\n      animating: animateTo !== null,\n      sticky,\n      target\n    }\n  ]);\n\n  return (\n    <InternalContext.Provider value={internalContext}>\n      <FunctionContext.Provider value={functionContext}>\n        <StateContext.Provider value={combinedStateContext}>\n          <State1Context.Provider value={state1Context}>\n            <State2Context.Provider value={state2Context}>\n              {children}\n              {target && <EventSpy debounce={debounce} name=\"scroll\" onEvent={handleScroll} target={target} />}\n              {target && animateTo !== null && (\n                <SpineTo name=\"scrollTop\" onEnd={handleSpineToEnd} target={target} value={animateTo} />\n              )}\n            </State2Context.Provider>\n          </State1Context.Provider>\n        </StateContext.Provider>\n      </FunctionContext.Provider>\n    </InternalContext.Provider>\n  );\n};\n\nComposer.defaultProps = {\n  checkInterval: 100,\n  children: undefined,\n  debounce: 17,\n  debug: undefined,\n  initialScrollBehavior: 'smooth',\n  mode: undefined,\n  nonce: undefined,\n  scroller: DEFAULT_SCROLLER\n};\n\nComposer.propTypes = {\n  checkInterval: PropTypes.number,\n  children: PropTypes.any,\n  debounce: PropTypes.number,\n  debug: PropTypes.bool,\n  initialScrollBehavior: PropTypes.oneOf(['auto', 'smooth']),\n  mode: PropTypes.oneOf(['bottom', 'top']),\n  nonce: PropTypes.string,\n  scroller: PropTypes.func\n};\n\nexport default Composer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}